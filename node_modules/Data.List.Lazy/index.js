// Generated by psc-make version 0.6.9.5
"use strict";
var Control_Monad_ListT = require("Control.Monad.ListT");
var Prelude = require("Prelude");
var Data_Lazy = require("Data.Lazy");
var Data_Monoid = require("Data.Monoid");
var Data_Maybe = require("Data.Maybe");
var Data_Tuple = require("Data.Tuple");
var Data_Foldable = require("Data.Foldable");
var Data_Unfoldable = require("Data.Unfoldable");
var Data_Traversable = require("Data.Traversable");
var LazyList = function (x) {
    return x;
};
var zipWith$prime = Control_Monad_ListT["zipWith'"];
var zipWith = Control_Monad_ListT.zipWith;
var wrapLazy = Control_Monad_ListT.wrapLazy;
var wrapEffect = Control_Monad_ListT.wrapEffect;
var unfold = Control_Monad_ListT.unfold;
var uncons = Control_Monad_ListT.uncons;
var unLazyList = function (_594) {
    return _594;
};
var toArray = Control_Monad_ListT.toArray;
var takeWhile = Control_Monad_ListT.takeWhile;
var take = Control_Monad_ListT.take;
var tail = Control_Monad_ListT.tail;
var singleton = Control_Monad_ListT.singleton;
var repeat = Control_Monad_ListT.repeat;
var prepend$prime = Control_Monad_ListT["prepend'"];
var prepend = Control_Monad_ListT.prepend;
var nil = Control_Monad_ListT.nil;
var mapMaybe = Control_Monad_ListT.mapMaybe;
var iterate = Control_Monad_ListT.iterate;
var head = Control_Monad_ListT.head;
var fromEffect = Control_Monad_ListT.fromEffect;
var fromArray = Control_Monad_ListT.fromArray;
var foldableLazyList = new Data_Foldable.Foldable(function (__dict_Monoid_0) {
    return function (f) {
        return function (_597) {
            var foldMap$prime = function (l_1) {
                var g = function (_600) {
                    if (_600 instanceof Data_Maybe.Nothing) {
                        return Data_Monoid.mempty(__dict_Monoid_0);
                    };
                    if (_600 instanceof Data_Maybe.Just) {
                        return Prelude["<>"](__dict_Monoid_0["__superclass_Prelude.Semigroup_0"]())(f(_600.value0.value0))(foldMap$prime(_600.value0.value1));
                    };
                    throw new Error("Failed pattern match");
                };
                return g(Data_Lazy.force(uncons(Data_Lazy.monadLazy)(l_1)));
            };
            return foldMap$prime(_597);
        };
    };
}, function (f) {
    return function (b) {
        return function (_596) {
            var foldl$prime = function (b_2) {
                return function (l_1) {
                    var g = function (_599) {
                        if (_599 instanceof Data_Maybe.Nothing) {
                            return b_2;
                        };
                        if (_599 instanceof Data_Maybe.Just) {
                            return foldl$prime(f(b_2)(_599.value0.value0))(_599.value0.value1);
                        };
                        throw new Error("Failed pattern match");
                    };
                    return g(Data_Lazy.force(uncons(Data_Lazy.monadLazy)(l_1)));
                };
            };
            return foldl$prime(b)(_596);
        };
    };
}, function (f) {
    return function (b) {
        return function (_595) {
            var foldr$prime = function (b_2) {
                return function (l_1) {
                    var g = function (_598) {
                        if (_598 instanceof Data_Maybe.Nothing) {
                            return Prelude.pure(Data_Lazy.applicativeLazy)(b_2);
                        };
                        if (_598 instanceof Data_Maybe.Just) {
                            return Prelude["<$>"](Data_Lazy.functorLazy)(f(_598.value0.value0))(foldr$prime(b_2)(_598.value0.value1));
                        };
                        throw new Error("Failed pattern match");
                    };
                    return Prelude[">>="](Data_Lazy.bindLazy)(uncons(Data_Lazy.monadLazy)(l_1))(g);
                };
            };
            return Data_Lazy.force(foldr$prime(b)(_595));
        };
    };
});
var filter = Control_Monad_ListT.filter;
var dropWhile = Control_Monad_ListT.dropWhile;
var drop = Control_Monad_ListT.drop;
var cons$prime = Control_Monad_ListT["cons'"];
var catMaybes = Control_Monad_ListT.catMaybes;
module.exports = {
    LazyList: LazyList, 
    "zipWith'": zipWith$prime, 
    zipWith: zipWith, 
    wrapLazy: wrapLazy, 
    wrapEffect: wrapEffect, 
    unLazyList: unLazyList, 
    unfold: unfold, 
    uncons: uncons, 
    toArray: toArray, 
    takeWhile: takeWhile, 
    take: take, 
    tail: tail, 
    singleton: singleton, 
    repeat: repeat, 
    "prepend'": prepend$prime, 
    prepend: prepend, 
    nil: nil, 
    mapMaybe: mapMaybe, 
    iterate: iterate, 
    head: head, 
    fromEffect: fromEffect, 
    fromArray: fromArray, 
    filter: filter, 
    dropWhile: dropWhile, 
    drop: drop, 
    "cons'": cons$prime, 
    catMaybes: catMaybes, 
    foldableLazyList: foldableLazyList
};
