// Generated by psc-make version 0.6.9.5
"use strict";
var Data_Function = require("Data.Function");
var Prelude = require("Prelude");
var Data_Either = require("Data.Either");
var Control_Monad_Eff = require("Control.Monad.Eff");
var Control_Monad_Cont_Trans = require("Control.Monad.Cont.Trans");
var Rx = require('rx');

var loadNotification = new Rx.Subject();

   function fetchImpl(url, onSuccess, onFailure) {
    setTimeout(function(){ 
     console.log('requests ' + url);
     fetch(url)
       .then(function (response) { return response.json(); })
       .then(function (json) { return JSON.stringify(json); })
       .then(function (json) { return json.replace(/"([^"]+)":/g,function($0,$1){return ('"'+$1.toLowerCase()+'":');}); })
       .then(function (json) { return JSON.parse(json); })
       .then(function (x) {
         onSuccess(x);
         loadNotification.onNext(x);
        })
       .catch(function (error) {
         onFailure(error);
        });
     }, 250);
  }
  ;
var fetchCb = function (url) {
    return function (k) {
        return fetchImpl(url, Prelude["<<<"](Prelude.semigroupoidArr)(k)(Data_Either.Right.create), Prelude["<<<"](Prelude.semigroupoidArr)(k)(Data_Either.Left.create));
    };
};
var fetchSafe = function (path) {
    return Control_Monad_Cont_Trans.ContT(fetchCb(path));
};
var fetchUrl = function (path) {
    return Prelude["<$>"](Control_Monad_Cont_Trans.functorContT(Control_Monad_Eff.monadEff))(function (_124) {
        if (_124 instanceof Data_Either.Right) {
            return _124.value0;
        };
        throw new Error("Failed pattern match");
    })(fetchSafe(path));
};
module.exports = {
    fetchUrl: fetchUrl,
    loadNotification: loadNotification
};
