-- Generated by psc-make version 0.6.9.5
module Data.Sequence.Ordered where
import Data.Sequence.Internal ()
import Data.FingerTree ()
import Prelude ()
import Data.Sequence.Ordered ()
import Data.Foldable ()
import Data.Monoid.Additive ()
import Data.Tuple ()
import Data.Lazy ()
import Prim ()
import Prelude ()
import Data.Lazy ()
import Data.Tuple ()
import Data.Maybe ()
import Data.Monoid ()
import Data.Monoid.Additive ()
import Data.Foldable ()
import Data.Traversable ()
import Data.Unfoldable ()
import Data.Sequence.Internal ()
import Data.FingerTree ()
--  | An ordered sequence. The Semigroup instance uses the `merge` function.
--  | O(1). Remove the least element of the sequence, returning that element and
--  | the remainder of the sequence. If the sequence is empty, return Nothing.
--  | O(1). Remove the greatest element of the sequence, returning that element
--  | and the remainder of the sequence. If the sequence is empty, return
--  | Nothing.
--  | O(log(n)). Split an ordered sequence into two halves. The first element
--  | of the returned tuple contains all elements which compared less than or
--  | equal to the argument; the second element contains the rest.
--  | O(1). Returns true if the given sequence is empty, false otherwise.
--  | O(m*log(n/m)), where m and n are the lengths of the longer and shorter
--  | sequences respectively. Create a new sequence containing every element
--  | in both of the given sequences.
--  | O(1). Access the least element of the sequence, or Nothing if the sequence
--  | is empty.
--  | O(n*log(n)), where n is the length of the longer sequence. Create a new
--  | sequence containing only elements which are common to both sequences.
--  | O(log(n)). Insert the given value into the correct place in the sequence.
--  | O(1). Access the greatest element of the sequence, or Nothing if the
--  | sequence is empty.
--  | Probably O(n), but depends on the Unfoldable instance. Unfold an ordered
--  | sequence in descending order.
--  | Probably O(n), but depends on the Unfoldable instance. Unfold an ordered
--  | sequence in ascending order.
--  | O(n). Return the length of the sequence.
--  TODO: there may be a better implementation for intersection.
--  `fmap OrdSeq` is a no-op, since OrdSeq is a newtype. Use this function
--  instead to avoid an unnecessary traversal of the structure.
--  | Probably O(n*log(n)), but depends on the Foldable instance. Consruct an
--  | ordered sequence from any any `Foldable`.
--  | Sort any structure (which has Foldable, Unfoldable, and Functor instances)
--  | by converting to an OrdSeq and back again. I am fairly sure this is
--  | usually O(n*log(n)), although of course this depends on the Unfoldable and
--  | Foldable instances.
--  | O(log(n)). Delete all elements from the sequence which compare EQ to the
--  | given value.
data OrdSeq (a :: *)
foreign import sort :: forall f a. (Prelude.Functor f, Data.Foldable.Foldable f, Data.Unfoldable.Unfoldable f, Prelude.Ord a) => f a -> f a
foreign import fromOrdSeqDescending :: forall f a. (Prelude.Functor f, Data.Unfoldable.Unfoldable f) => Data.Sequence.Ordered.OrdSeq a -> f a
foreign import fromOrdSeq :: forall f a. (Prelude.Functor f, Data.Unfoldable.Unfoldable f) => Data.Sequence.Ordered.OrdSeq a -> f a
foreign import deleteAll :: forall a. (Prelude.Ord a) => a -> Data.Sequence.Ordered.OrdSeq a -> Data.Sequence.Ordered.OrdSeq a
foreign import intersection :: forall a. (Prelude.Ord a) => Data.Sequence.Ordered.OrdSeq a -> Data.Sequence.Ordered.OrdSeq a -> Data.Sequence.Ordered.OrdSeq a
foreign import merge :: forall a. (Prelude.Ord a) => Data.Sequence.Ordered.OrdSeq a -> Data.Sequence.Ordered.OrdSeq a -> Data.Sequence.Ordered.OrdSeq a
foreign import partition :: forall a. (Prelude.Ord a) => a -> Data.Sequence.Ordered.OrdSeq a -> Data.Tuple.Tuple (Data.Sequence.Ordered.OrdSeq a) (Data.Sequence.Ordered.OrdSeq a)
foreign import popGreatest :: forall a. (Prelude.Ord a) => Data.Sequence.Ordered.OrdSeq a -> Data.Maybe.Maybe (Data.Tuple.Tuple a (Data.Sequence.Ordered.OrdSeq a))
foreign import popLeast :: forall a. (Prelude.Ord a) => Data.Sequence.Ordered.OrdSeq a -> Data.Maybe.Maybe (Data.Tuple.Tuple a (Data.Sequence.Ordered.OrdSeq a))
foreign import greatest :: forall a. (Prelude.Ord a) => Data.Sequence.Ordered.OrdSeq a -> Data.Maybe.Maybe a
foreign import least :: forall a. (Prelude.Ord a) => Data.Sequence.Ordered.OrdSeq a -> Data.Maybe.Maybe a
foreign import length :: forall a. Data.Sequence.Ordered.OrdSeq a -> Prim.Number
foreign import null :: forall a. Data.Sequence.Ordered.OrdSeq a -> Prim.Boolean
foreign import insert :: forall a. (Prelude.Ord a) => a -> Data.Sequence.Ordered.OrdSeq a -> Data.Sequence.Ordered.OrdSeq a
foreign import toOrdSeq :: forall f a. (Data.Foldable.Foldable f, Prelude.Ord a) => f a -> Data.Sequence.Ordered.OrdSeq a
foreign import empty :: forall a. Data.Sequence.Ordered.OrdSeq a
foreign import instance eqOrdSeq :: (Prelude.Eq a) => Prelude.Eq (Data.Sequence.Ordered.OrdSeq a)
foreign import instance showOrdSeq :: (Prelude.Show a) => Prelude.Show (Data.Sequence.Ordered.OrdSeq a)
foreign import instance semigroupOrdSeq :: (Prelude.Ord a) => Prelude.Semigroup (Data.Sequence.Ordered.OrdSeq a)
foreign import instance monoidOrdSeq :: (Prelude.Ord a) => Data.Monoid.Monoid (Data.Sequence.Ordered.OrdSeq a)
foreign import instance foldableOrdSeq :: Data.Foldable.Foldable Data.Sequence.Ordered.OrdSeq
