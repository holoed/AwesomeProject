-- Generated by psc-make version 0.6.9.5
module Data.Sequence.Internal where
import Prelude.Unsafe ()
import Prelude ()
import Data.Sequence.Internal ()
import Data.Foldable ()
import Data.Monoid ()
import Data.Lazy ()
import Prim ()
import Prelude ()
import Prelude.Unsafe ()
import Data.Monoid ()
import Data.Monoid.Additive ()
import Data.Maybe ()
import Data.Tuple ()
import Data.Foldable ()
import Data.Traversable ()
import Data.Array ()
import Data.Lazy ()
-- --------------------------------------
--  FingerTree/Sequence specific stuff
-- --------------------------------------
--  FingerTree/Sequence specific stuff
--  With great power comes great responsibility. Always define an alias of
--  this with a type signature which is as specific as possible, never use it
--  directly.
-- ---------------------
--  Various utilities
-- --------------------------------------
--  FingerTree/Sequence specific stuff
--  `fmap getElem` is a no-op, since Elem is a newtype. Use this function
--  instead to avoid an unnecessary traversal of the structure.
--  `fmap Elem` is a no-op, since Elem is a newtype. Use this function instead
--  to avoid an unnecessary traversal of the structure.
data Key (a :: *) = NoKey  | Key a
newtype Elem (a :: *) = Elem a
class Measured a v where
  measure :: a -> v
foreign import liftElem :: forall a b. (a -> b) -> Data.Sequence.Internal.Elem a -> b
foreign import lift2Elem :: forall a b. (b -> a -> b) -> b -> Data.Sequence.Internal.Elem a -> b
foreign import fmapGetElem :: forall f a. (Prelude.Functor f) => f (Data.Sequence.Internal.Elem a) -> f a
foreign import fmapElem :: forall f a. (Prelude.Functor f) => f a -> f (Data.Sequence.Internal.Elem a)
foreign import getElem :: forall a. Data.Sequence.Internal.Elem a -> a
foreign import unsafeCoerce :: forall a b. a -> b
foreign import strJoin :: forall a. (Prelude.Show a) => Prim.String -> [a] -> Prim.String
foreign import (<$$$>) :: forall f g h a b. (Prelude.Functor f, Prelude.Functor g, Prelude.Functor h) => (a -> b) -> f (g (h a)) -> f (g (h b))
foreign import (<$$>) :: forall f g a b. (Prelude.Functor f, Prelude.Functor g) => (a -> b) -> f (g a) -> f (g b)
foreign import fmap :: forall f a b. (Prelude.Functor f) => (a -> b) -> f a -> f b
foreign import (***) :: forall a b aa bb. (a -> aa) -> (b -> bb) -> Data.Tuple.Tuple a b -> Data.Tuple.Tuple aa bb
foreign import (!) :: forall a. [a] -> Prim.Number -> a
foreign import instance measuredArray :: (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => Data.Sequence.Internal.Measured [a] v
foreign import instance measuredLazy :: (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => Data.Sequence.Internal.Measured (Data.Lazy.Lazy a) v
foreign import instance measuredElem :: Data.Sequence.Internal.Measured (Data.Sequence.Internal.Elem a) (Data.Monoid.Additive.Additive Prim.Number)
foreign import instance showElem :: (Prelude.Show a) => Prelude.Show (Data.Sequence.Internal.Elem a)
foreign import instance eqElem :: (Prelude.Eq a) => Prelude.Eq (Data.Sequence.Internal.Elem a)
foreign import instance ordElem :: (Prelude.Ord a) => Prelude.Ord (Data.Sequence.Internal.Elem a)
foreign import instance foldableElem :: Data.Foldable.Foldable Data.Sequence.Internal.Elem
foreign import instance functorElem :: Prelude.Functor Data.Sequence.Internal.Elem
foreign import instance traversableElem :: Data.Traversable.Traversable Data.Sequence.Internal.Elem
foreign import instance eqKey :: (Prelude.Eq a) => Prelude.Eq (Data.Sequence.Internal.Key a)
foreign import instance showKey :: (Prelude.Show a) => Prelude.Show (Data.Sequence.Internal.Key a)
foreign import instance semigroupKey :: Prelude.Semigroup (Data.Sequence.Internal.Key a)
foreign import instance ordKey :: (Prelude.Ord a) => Prelude.Ord (Data.Sequence.Internal.Key a)
foreign import instance monoidKey :: Data.Monoid.Monoid (Data.Sequence.Internal.Key a)
foreign import instance measuredElemKey :: Data.Sequence.Internal.Measured (Data.Sequence.Internal.Elem a) (Data.Sequence.Internal.Key a)
