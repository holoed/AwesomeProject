-- Generated by psc-make version 0.6.9.5
module Data.Sequence where
import Data.Sequence.Internal ()
import Data.FingerTree ()
import Prelude ()
import Data.Sequence ()
import Data.Foldable ()
import Data.Traversable ()
import Data.Unfoldable ()
import Data.Monoid.Additive ()
import Data.Lazy ()
import Data.Tuple ()
import Prim ()
import Prelude ()
import Data.Lazy ()
import Data.Monoid ()
import Data.Monoid.Additive ()
import Data.Tuple ()
import Data.Maybe ()
import Data.Foldable ()
import Data.Unfoldable ()
import Data.Traversable ()
import Control.Alt ()
import Control.Plus ()
import Control.Alternative ()
import Control.MonadPlus ()
import Data.Sequence.Internal ()
import Data.FingerTree ()
--  TODO: Optimise Apply instance (see Hackage)
--  TODO: adjust might be suboptimal, see Data.Sequence on Hackage
--  TODO: toSeq can be improved. See Hackage
--  | O(1). If the sequence is nonempty, take one element off its right side and
--  | return that together with the rest of the original sequence. Otherwise,
--  | return Nothing.
--  | O(log(min(i,n-i))). Like `index`, but this function will throw an error
--  | instead of returning Nothing if no element exists at the specified
--  | sequence.
--  | O(1). If the sequence is nonempty, take one element off its left side and
--  | return that together with the rest of the original sequence. Otherwise,
--  | return Nothing.
--  | O(log(min(i,n-i))). Take a certain number of values from the left end of
--  | a sequence, and discard the rest.
--  | O(log(min(i,n-i))). Split the sequence into two subsequences. The first
--  | subsequence will have i elements (unless there are not that many in the
--  | whole sequence, in which case the first element is the same sequence,
--  | unchanged).
--  | O(1). Add an element to the right end of a Seq.
--  | O(1). True if the sequence has no elements, false otherwise.
--  | O(1). The number of elements in the sequence.
--  | O(1). Get the last element of a Seq. Equivalent to
--  | `\seq -> index seq (length seq - 1)`.
--  | O(1). True if the given index specifies an element that exists in the
--  | sequence, false otherwise.
--  | O(log(min(i,n-i))). Retrieve the element at the given index in the
--  | sequence. This function is zero-based; that is, the first element in a
--  | sequence `xs` can be retrieved with `index xs 0`.
--  | O(1). Get the first element of a Seq. Equivalent to `\seq -> index seq 0`.
--  | Probably O(n), but depends on the Unfoldable instance. Turn a `Seq` into
--  | any `Unfoldable`.
--  `fmap Seq` is a no-op, since Seq is a newtype. Use this function instead
--  to avoid an unnecessary traversal of the structure.
--  | O(1). Get all but the last element of a Seq. Equivalent to `\seq -> take
--  | (length seq - 1)`.
--  | O(1). Get all but the first element of a Seq. Equivalent to `drop 1`.
--  | O(n). Create a new Seq which contains only those elements of the input
--  | Seq which satisfy the given predicate.
--  | A sequence with no elements.
--  | O(log(min(i,n-i))). Discard a given number of elements from the left side
--  | of a Seq.
--  | O(1). Add an element to the left end of a Seq.
--  | O(1). Create a Seq with one element.
--  | Probably O(n*log(n)), but depends on the Foldable instance. Turn any
--  | `Foldable` into a `Seq`.
--  | O(log(min(i,n-i))). Join two Seqs together.
--  | O(log(min(i,n-i))). Adjust the element at the specified index by
--  | applying the given function to it. If the index is out of range, the
--  | sequence is returned unchanged.
--  | O(log(min(i,n-i))). Replace the element at the specified index with
--  | a new element. If the index is out of range, the sequence is returned
--  | unchanged.
data Seq (a :: *)
foreign import fromSeq :: forall f a. (Prelude.Functor f, Data.Unfoldable.Unfoldable f) => Data.Sequence.Seq a -> f a
foreign import replace :: forall a. a -> Prim.Number -> Data.Sequence.Seq a -> Data.Sequence.Seq a
foreign import adjust :: forall a. (a -> a) -> Prim.Number -> Data.Sequence.Seq a -> Data.Sequence.Seq a
foreign import index :: forall a. Data.Sequence.Seq a -> Prim.Number -> Data.Maybe.Maybe a
foreign import filter :: forall a. (a -> Prim.Boolean) -> Data.Sequence.Seq a -> Data.Sequence.Seq a
foreign import drop :: forall a. Prim.Number -> Data.Sequence.Seq a -> Data.Sequence.Seq a
foreign import take :: forall a. Prim.Number -> Data.Sequence.Seq a -> Data.Sequence.Seq a
foreign import splitAt :: forall a. Prim.Number -> Data.Sequence.Seq a -> Data.Tuple.Tuple (Data.Sequence.Seq a) (Data.Sequence.Seq a)
foreign import last :: forall a. Data.Sequence.Seq a -> Data.Maybe.Maybe a
foreign import init :: forall a. Data.Sequence.Seq a -> Data.Maybe.Maybe (Data.Sequence.Seq a)
foreign import tail :: forall a. Data.Sequence.Seq a -> Data.Maybe.Maybe (Data.Sequence.Seq a)
foreign import head :: forall a. Data.Sequence.Seq a -> Data.Maybe.Maybe a
foreign import unsnoc :: forall a. Data.Sequence.Seq a -> Data.Maybe.Maybe (Data.Tuple.Tuple (Data.Sequence.Seq a) a)
foreign import uncons :: forall a. Data.Sequence.Seq a -> Data.Maybe.Maybe (Data.Tuple.Tuple a (Data.Sequence.Seq a))
foreign import inBounds :: forall a. Data.Sequence.Seq a -> Prim.Number -> Prim.Boolean
foreign import null :: forall a. Data.Sequence.Seq a -> Prim.Boolean
foreign import length :: forall a. Data.Sequence.Seq a -> Prim.Number
foreign import toSeq :: forall f a. (Data.Foldable.Foldable f) => f a -> Data.Sequence.Seq a
foreign import append :: forall a. Data.Sequence.Seq a -> Data.Sequence.Seq a -> Data.Sequence.Seq a
foreign import snoc :: forall a. Data.Sequence.Seq a -> a -> Data.Sequence.Seq a
foreign import cons :: forall a. a -> Data.Sequence.Seq a -> Data.Sequence.Seq a
foreign import singleton :: forall a. a -> Data.Sequence.Seq a
foreign import empty :: forall a. Data.Sequence.Seq a
foreign import instance ordSeq :: (Prelude.Ord a) => Prelude.Ord (Data.Sequence.Seq a)
foreign import instance eqSeq :: (Prelude.Eq a) => Prelude.Eq (Data.Sequence.Seq a)
foreign import instance showSeq :: (Prelude.Show a) => Prelude.Show (Data.Sequence.Seq a)
foreign import instance semigroupSeq :: Prelude.Semigroup (Data.Sequence.Seq a)
foreign import instance monoidSeq :: Data.Monoid.Monoid (Data.Sequence.Seq a)
foreign import instance foldableSeq :: Data.Foldable.Foldable Data.Sequence.Seq
foreign import instance traversableSeq :: Data.Traversable.Traversable Data.Sequence.Seq
foreign import instance unfoldableSeq :: Data.Unfoldable.Unfoldable Data.Sequence.Seq
foreign import instance functorSeq :: Prelude.Functor Data.Sequence.Seq
foreign import instance applySeq :: Prelude.Apply Data.Sequence.Seq
foreign import instance applicativeSeq :: Prelude.Applicative Data.Sequence.Seq
foreign import instance bindSeq :: Prelude.Bind Data.Sequence.Seq
foreign import instance monadSeq :: Prelude.Monad Data.Sequence.Seq
foreign import instance altSeq :: Control.Alt.Alt Data.Sequence.Seq
foreign import instance plusSeq :: Control.Plus.Plus Data.Sequence.Seq
foreign import instance alternativeSeq :: Control.Alternative.Alternative Data.Sequence.Seq
foreign import instance monadPlusSeq :: Control.MonadPlus.MonadPlus Data.Sequence.Seq
