-- Generated by psc-make version 0.6.9.5
module Data.FingerTree where
import Prelude ()
import Data.Sequence.Internal ()
import Data.Foldable ()
import Data.Monoid ()
import Data.Traversable ()
import Data.Lazy ()
import Data.FingerTree ()
import Data.Array ()
import Data.Array.Unsafe ()
import Data.Unfoldable ()
import Prim ()
import Prelude ()
import Data.Monoid ()
import Data.Array ()
import Data.Array.Unsafe ()
import Data.Maybe ()
import Data.Tuple ()
import Data.Lazy ()
import Data.Foldable ()
import Data.Unfoldable ()
import Data.Traversable ()
import Data.Sequence.Internal ()
--  Digit has one to four elements.
--  If Digit has two or three elements, it is safe; otherwise it is dangerous.
--  Deep node may have debits, the cost of suspended code, as many as safe
--  digits it has (i.e., 0, 1, or 2).
--  unsafe
--  We don't implement an Eq instance because we don't want to make assumptions
--  about the meaning of the data, and because we expect actual uses of
--  FingerTrees to use newtypes, so we provide this function instead to help
--  with defining Ord instances.
--  unsafe
--  We don't implement an Ord instance because we can't implement a good Eq
--  instance, and because we expect actual uses of FingerTrees to use newtypes,
--  so we provide this function instead to help with defining Ord instances.
data LazySplit (f :: * -> *) (a :: *) = LazySplit (Data.Lazy.Lazy (f a)) a (Data.Lazy.Lazy (f a))
data Split (f :: * -> *) (a :: *) = Split (f a) a (f a)
data ViewR (s :: * -> *) (a :: *) = NilR  | SnocR (Data.Lazy.Lazy (s a)) a
data ViewL (s :: * -> *) (a :: *) = NilL  | ConsL a (Data.Lazy.Lazy (s a))
type Digit (a :: *) = [a]
data FingerTree (v :: *) (a :: *) = Empty  | Single a | Deep (Data.Lazy.Lazy v) (Data.FingerTree.Digit a) (Data.Lazy.Lazy (Data.FingerTree.FingerTree v (Data.FingerTree.Node v a))) (Data.FingerTree.Digit a)
data Node (v :: *) (a :: *) = Node2 v a a | Node3 v a a a
foreign import unfoldRight :: forall f a v. (Data.Unfoldable.Unfoldable f, Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => Data.FingerTree.FingerTree v a -> f a
foreign import unfoldLeft :: forall f a v. (Data.Unfoldable.Unfoldable f, Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => Data.FingerTree.FingerTree v a -> f a
foreign import filter :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => (a -> Prim.Boolean) -> Data.FingerTree.FingerTree v a -> Data.FingerTree.FingerTree v a
foreign import split :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => (v -> Prim.Boolean) -> Data.FingerTree.FingerTree v a -> Data.Tuple.Tuple (Data.Lazy.Lazy (Data.FingerTree.FingerTree v a)) (Data.Lazy.Lazy (Data.FingerTree.FingerTree v a))
foreign import unsafeSplitTree :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => (v -> Prim.Boolean) -> v -> Data.FingerTree.FingerTree v a -> Data.FingerTree.LazySplit (Data.FingerTree.FingerTree v) a
foreign import splitDigit :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => (v -> Prim.Boolean) -> v -> Data.FingerTree.Digit a -> Data.FingerTree.Split Prim.Array a
foreign import append :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => Data.FingerTree.FingerTree v a -> Data.FingerTree.FingerTree v a -> Data.FingerTree.FingerTree v a
foreign import nodes :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => [a] -> [Data.FingerTree.Node v a]
foreign import app3 :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => Data.FingerTree.FingerTree v a -> [a] -> Data.FingerTree.FingerTree v a -> Data.FingerTree.FingerTree v a
foreign import init :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => Data.FingerTree.FingerTree v a -> Data.Maybe.Maybe (Data.FingerTree.FingerTree v a)
foreign import last :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => Data.FingerTree.FingerTree v a -> Data.Maybe.Maybe a
foreign import deepR :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => [a] -> Data.Lazy.Lazy (Data.FingerTree.FingerTree v (Data.FingerTree.Node v a)) -> [a] -> Data.FingerTree.FingerTree v a
foreign import viewR :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => Data.FingerTree.FingerTree v a -> Data.FingerTree.ViewR (Data.FingerTree.FingerTree v) a
foreign import initDigit :: forall a. Data.FingerTree.Digit a -> Data.FingerTree.Digit a
foreign import lastDigit :: forall a. Data.FingerTree.Digit a -> a
foreign import tail :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => Data.FingerTree.FingerTree v a -> Data.Maybe.Maybe (Data.FingerTree.FingerTree v a)
foreign import head :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => Data.FingerTree.FingerTree v a -> Data.Maybe.Maybe a
foreign import isEmpty :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => Data.FingerTree.FingerTree v a -> Prim.Boolean
foreign import deepL :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => Data.FingerTree.Digit a -> Data.Lazy.Lazy (Data.FingerTree.FingerTree v (Data.FingerTree.Node v a)) -> [a] -> Data.FingerTree.FingerTree v a
foreign import viewL :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => Data.FingerTree.FingerTree v a -> Data.FingerTree.ViewL (Data.FingerTree.FingerTree v) a
foreign import tailDigit :: forall a. Data.FingerTree.Digit a -> Data.FingerTree.Digit a
foreign import headDigit :: forall a. Data.FingerTree.Digit a -> a
foreign import toFingerTree :: forall f a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v, Data.Foldable.Foldable f) => f a -> Data.FingerTree.FingerTree v a
foreign import snocAll :: forall f a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v, Data.Foldable.Foldable f) => Data.FingerTree.FingerTree v a -> f a -> Data.FingerTree.FingerTree v a
foreign import consAll :: forall f a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v, Data.Foldable.Foldable f) => f a -> Data.FingerTree.FingerTree v a -> Data.FingerTree.FingerTree v a
foreign import snoc :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => Data.FingerTree.FingerTree v a -> a -> Data.FingerTree.FingerTree v a
foreign import cons :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => a -> Data.FingerTree.FingerTree v a -> Data.FingerTree.FingerTree v a
foreign import compareFingerTree :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v, Prelude.Ord a) => Data.FingerTree.FingerTree v a -> Data.FingerTree.FingerTree v a -> Prelude.Ordering
foreign import eqFingerTree :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v, Prelude.Eq a) => Data.FingerTree.FingerTree v a -> Data.FingerTree.FingerTree v a -> Prim.Boolean
foreign import deep :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => Data.FingerTree.Digit a -> Data.Lazy.Lazy (Data.FingerTree.FingerTree v (Data.FingerTree.Node v a)) -> Data.FingerTree.Digit a -> Data.FingerTree.FingerTree v a
foreign import lazyEmpty :: forall v a. Data.Lazy.Lazy (Data.FingerTree.FingerTree v a)
foreign import nodeToDigit :: forall a v. Data.FingerTree.Node v a -> Data.FingerTree.Digit a
foreign import node3 :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => a -> a -> a -> Data.FingerTree.Node v a
foreign import node2 :: forall a v. (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => a -> a -> Data.FingerTree.Node v a
foreign import instance showNode :: (Prelude.Show a, Prelude.Show v) => Prelude.Show (Data.FingerTree.Node v a)
foreign import instance functorNode :: Prelude.Functor (Data.FingerTree.Node v)
foreign import instance foldableNode :: Data.Foldable.Foldable (Data.FingerTree.Node v)
foreign import instance traversableNode :: Data.Traversable.Traversable (Data.FingerTree.Node v)
foreign import instance measuredNode :: Data.Sequence.Internal.Measured (Data.FingerTree.Node v a) v
foreign import instance showFingerTree :: (Prelude.Show v, Prelude.Show a) => Prelude.Show (Data.FingerTree.FingerTree v a)
foreign import instance semigroupFingerTree :: (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => Prelude.Semigroup (Data.FingerTree.FingerTree v a)
foreign import instance functorFingerTree :: Prelude.Functor (Data.FingerTree.FingerTree v)
foreign import instance foldableFingerTree :: Data.Foldable.Foldable (Data.FingerTree.FingerTree v)
foreign import instance traversableFingerTree :: Data.Traversable.Traversable (Data.FingerTree.FingerTree v)
foreign import instance measuredFingerTree :: (Data.Monoid.Monoid v, Data.Sequence.Internal.Measured a v) => Data.Sequence.Internal.Measured (Data.FingerTree.FingerTree v a) v
foreign import instance functorViewL :: (Prelude.Functor s) => Prelude.Functor (Data.FingerTree.ViewL s)
