-- Generated by psc-make version 0.6.9.5
module Data.Sequence.NonEmpty where
import Data.Sequence ()
import Prelude ()
import Data.Tuple ()
import Data.Sequence.NonEmpty ()
import Data.Maybe ()
import Data.Foldable ()
import Data.Traversable ()
import Prim ()
import Prelude ()
import Control.Alt ()
import Data.Foldable ()
import Data.Traversable ()
import Data.Maybe ()
import Data.Tuple ()
import Data.Unfoldable ()
import Data.Sequence ()
--  | A sequence which is guaranteed to contain at least one element.
--  | O(1). Take one element off the right side of a Seq and return it, together
--  | with the (possibly empty) remainder of the Seq.
--  | O(1). Take one element off the left side of a Seq and return it, together
--  | with the (possibly empty) remainder of the Seq.
--  | O(1). Turn a non-empty sequence into a "plain" sequence (i.e. one from
--  | Data.Sequence), containing the same elements.
--  | O(log(min(i,n-i))). Take a certain number of values from the left end of
--  | a sequence, and discard the rest, returning a possibly empty sequence.
--  | O(1). Get all but the first element of a non-empty sequence. The returned
--  | sequence is possibly empty. Equivalent to `drop 1`.
--  | O(log(min(i,n-i))). Split the sequence into two (possibly empty) subsequences.
--  | The first subsequence will have i elements (unless there are not that many in
--  | the whole sequence, in which case the first element is the same sequence,
--  | unchanged).
--  | O(1). Add an element to the right end of a sequence.
--  | O(1). Construct a sequence from a single element.
--  | O(1). The number of elements in the sequence.
--  | O(1). Get the last element of a non-empty sequence.
--  | O(1). Get all but the last element of a non-empty sequence. Possibly empty.
--  | O(log(min(i,n-i))). Retrieve the element at the given index in the
--  | sequence. This function is zero-based; that is, the first element in a
--  | sequence `xs` can be retrieved with `index xs 0`.
--  | O(1). True if the given index specifies an element that exists in the
--  | sequence, false otherwise.
--  | O(1). Get the first element of a non-empty sequence. Equivalent to `\seq
--  | -> index seq 0`.
--  | Probably O(n), but depends on the Unfoldable instance. Turn a `Seq` into
--  | any `Unfoldable`.
--  | O(n). Create a new (possibly empty) sequence which contains only those
--  | elements of the input sequence which satisfy the given predicate.
--  | O(log(min(i,n-i))). Discard a given number of elements from the left end
--  | of a sequence, returning a possibly empty sequence.
--  | O(1). Add an element to the left end of a sequence.
--  | O(log(min(i,n-i))). Join two sequence values together.
--  | O(log(min(i,n-i))). Adjust the element at the specified index by
--  | applying the given function to it. If the index is out of range, the
--  | sequence is returned unchanged.
--  | O(log(min(i,n-i))). Replace the element at the specified index with
--  | a new element. If the index is out of range, the sequence is returned
--  | unchanged.
data Seq (a :: *) = Seq a (Data.Sequence.Seq a)
foreign import fromSeq :: forall f a. (Prelude.Functor f, Data.Unfoldable.Unfoldable f) => Data.Sequence.NonEmpty.Seq a -> f a
foreign import replace :: forall a. a -> Prim.Number -> Data.Sequence.NonEmpty.Seq a -> Data.Sequence.NonEmpty.Seq a
foreign import adjust :: forall a. (a -> a) -> Prim.Number -> Data.Sequence.NonEmpty.Seq a -> Data.Sequence.NonEmpty.Seq a
foreign import index :: forall a. Data.Sequence.NonEmpty.Seq a -> Prim.Number -> Data.Maybe.Maybe a
foreign import filter :: forall a. (a -> Prim.Boolean) -> Data.Sequence.NonEmpty.Seq a -> Data.Sequence.Seq a
foreign import drop :: forall a. Prim.Number -> Data.Sequence.NonEmpty.Seq a -> Data.Sequence.Seq a
foreign import take :: forall a. Prim.Number -> Data.Sequence.NonEmpty.Seq a -> Data.Sequence.Seq a
foreign import splitAt :: forall a. Prim.Number -> Data.Sequence.NonEmpty.Seq a -> Data.Tuple.Tuple (Data.Sequence.Seq a) (Data.Sequence.Seq a)
foreign import toPlain :: forall a. Data.Sequence.NonEmpty.Seq a -> Data.Sequence.Seq a
foreign import last :: forall a. Data.Sequence.NonEmpty.Seq a -> a
foreign import init :: forall a. Data.Sequence.NonEmpty.Seq a -> Data.Sequence.Seq a
foreign import tail :: forall a. Data.Sequence.NonEmpty.Seq a -> Data.Sequence.Seq a
foreign import head :: forall a. Data.Sequence.NonEmpty.Seq a -> a
foreign import unsnoc :: forall a. Data.Sequence.NonEmpty.Seq a -> Data.Tuple.Tuple (Data.Sequence.Seq a) a
foreign import uncons :: forall a. Data.Sequence.NonEmpty.Seq a -> Data.Tuple.Tuple a (Data.Sequence.Seq a)
foreign import inBounds :: forall a. Data.Sequence.NonEmpty.Seq a -> Prim.Number -> Prim.Boolean
foreign import length :: forall a. Data.Sequence.NonEmpty.Seq a -> Prim.Number
foreign import append :: forall a. Data.Sequence.NonEmpty.Seq a -> Data.Sequence.NonEmpty.Seq a -> Data.Sequence.NonEmpty.Seq a
foreign import snoc :: forall a. Data.Sequence.NonEmpty.Seq a -> a -> Data.Sequence.NonEmpty.Seq a
foreign import cons :: forall a. a -> Data.Sequence.NonEmpty.Seq a -> Data.Sequence.NonEmpty.Seq a
foreign import singleton :: forall a. a -> Data.Sequence.NonEmpty.Seq a
foreign import instance showSeq :: (Prelude.Show a) => Prelude.Show (Data.Sequence.NonEmpty.Seq a)
foreign import instance eqSeq :: (Prelude.Eq a) => Prelude.Eq (Data.Sequence.NonEmpty.Seq a)
foreign import instance ordSeq :: (Prelude.Ord a) => Prelude.Ord (Data.Sequence.NonEmpty.Seq a)
foreign import instance functorSeq :: Prelude.Functor Data.Sequence.NonEmpty.Seq
foreign import instance applySeq :: Prelude.Apply Data.Sequence.NonEmpty.Seq
foreign import instance applicativeSeq :: Prelude.Applicative Data.Sequence.NonEmpty.Seq
foreign import instance bindSeq :: Prelude.Bind Data.Sequence.NonEmpty.Seq
foreign import instance monadSeq :: Prelude.Monad Data.Sequence.NonEmpty.Seq
foreign import instance semigroupSeq :: Prelude.Semigroup (Data.Sequence.NonEmpty.Seq a)
foreign import instance altSeq :: Control.Alt.Alt Data.Sequence.NonEmpty.Seq
foreign import instance foldableSeq :: Data.Foldable.Foldable Data.Sequence.NonEmpty.Seq
foreign import instance traversableSeq :: Data.Traversable.Traversable Data.Sequence.NonEmpty.Seq
